// 작성일 : 2019년 02월 28일 
/*======================
 ■■■ 배열 ■■■
 - 배열의 복사 
=======================*/

/*
	○ 실습 문제

	임의의 배열(a,b)에 들어있는 숫자들의 합집합을 출력하는 프로그램을 구현한다.
	단, 중복이 제거된 상태의 합집합을 출력할 수 있도록 한다.
	또한, 배열 복사 개념을 적용시켜 처리할 수 있도록 한다.

	ex) 임의의 두 배열 
	int[] a = {2, 3, 7, 10, 11}
	int[] b = {3, 6, 10, 14}

	실행 예)
	첫 번째 배열 요소를 입력하세요(공백 구분) :
	두 번째 배열 요소를 입력하세요(공백 구분) :
	2 3 7 10 11 6 14
	계속하려면 아무키나 누르세요...

문자열 형태로 입력 받자. 

*/


public class Test099
{
	public static void main(String[] args)
	{
		// 임의의 두 배열 
		int[] a = {2, 3, 7, 10, 11};
		int[] b = {3, 6, 10, 14};

		//--==>> 결과 예상  → 2 3 7 10 11 6 14
		
		// 방법 ① 
		/*
		// - 집합 a의 전체 요소 출력

		for (int i=0; i<a.length; i++)
			System.out.printf("%3d", a[i]);

		// - 집합 b 의 요소 출력
		//	 단, 집합 b는 집합 a 의 요소와 중복되는 데이터를
		//	 제거하면서 출력

		for (int i=0; i<b.length; i++)		//4회전 → 3, 6, 10, 14 선택적 출력 
		{
			boolean flag = false;				// (추가설명) 중복된 값이 없다는 전제 → 중복되는 값을 만나면 

			for (int j=0; j<a.length; j++)	//5회전 
			{
				if (b[i] == a[j])				// (추가설명)중복된 값을 발견했다면, a의 나머지는 비교하지 말자. 
				{
					flag = true;			//-- 중복 확인 → 중복되었다!! 
					break;					//-- 멈춘다, 그리고 빠져나간다(j관련 반복문 탈출) 
				}
			}
			
			if (flag)						// flag가 true라면... 현재 값에 따라 true 이거나 false임. 
				continue;					//-- 뒷부분 무시하고... 계속해라... 
											// (추가설명) 중복된 값은 출력하지 말고, 큰 반복문으로

			System.out.printf("%3d", b[i]);	// 뒷부분
		}
		System.out.println();
		
		방법 ① end */ 


		// 방법 ②
		//배열의 가장 큰 특징
		//	1) 동질의 성격을 가진 요소가 있어야 한다. 동질 성격 데이터들의 모임
		//	2) 길이를 변화시킬 수 없다. 

		// - 임시 배열을 만들고 
		// int[] temp = new int [??????];
		int[] temp = new int[a.length + b.length];
	
		// - 만들어진 임시배열에 중복되지 않은 배열 요소를 채운 다음
		int n;		//-- check 변수 선언 위치 중요~!!! 
		
		for (n=0; n<a.length; n++)
		{
			temp[n] = a[n];
		}


		for (int k=0; k<b.length; k++)
		{
			boolean flag = false;
			
			for (int m=0; m<a.length; m++)	//5회전 
			{

				if (b[k] == a[m])				// (추가설명)중복된 값을 발견했다면, a의 나머지는 비교하지 말자. 
					flag = true;				//-- 중복 확인 → 중복되었다!! 
					break;						//-- 멈춘다, 그리고 빠져나간다(j관련 반복문 탈출) 
			}
			
				if (flag)						// flag가 true라면... 현재 값에 따라 true 이거나 false임. 
				continue;						//-- 뒷부분 무시하고... 계속해라... 
												// (추가설명) 중복된 값은 출력하지 말고, 큰 반복문으로

				temp[n] = b[k];
				n++;

		}
		// - 그렇게 구성된 임시 배열을 출력 
		for (int h=0; h<n; h++)
		{
			System.out.printf("%3d", temp[h]);
		}
		System.out.println();

	}
}
